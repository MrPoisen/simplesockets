{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to simplesockets This is the simplesockets documentation. Here, you can learn how to use this library. If you want to use the \"unsecure\" variant, use simplesockets If you want to use the \"secure\" variant, use securesockets . For this one, you need pycryptodome Here you can learn more about the simplesockets Here you can learn more about the securesockets If you need an example, you can find one in the example folder. If you want a simple echo Client, it could look something like this: if __name__ == \"__main__\" : from simplesockets.simplesockets import TCPClient Client = TCPClient () Client . setup ( target_ip = \"localhost\" , target_port = 25567 ) #prepares the Client Client . connect () #connects the Client to the Server Client . autorecv () #enables autorecv: automaticle saves all incoming data in Client.recved_data, # return them with Client.return_recved_data() Client . send_data ( b 'Test' ) #sends the text to the Server while True : if Client . event . new_data : #checks if any data recved data = Client . return_recved_data () #returns the recved data as a list for element in data : print ( element ) #should return b'Test' A simple echo Server could look something like this: if __name__ == \"__main__\" : from simplesockets.simplesockets import TCPServer Server = TCPServer () Server . setup ( ip = '127.0.0.1' , port = 25567 ) #prepares the server Server . start () #starts the server while True : if Server . event . new_data : #checks if any data recved data = Server . return_recved_data () #returns the recved data as a list for element in data : client_socket , address , data = element #data is saved like this (client_socket,address,recved_data) Server . send_data ( data , client_socket ) If you encounter any bugs, report them on github Should you be interested in the changelog, you can find it here","title":"Home"},{"location":"#welcome-to-simplesockets","text":"This is the simplesockets documentation. Here, you can learn how to use this library. If you want to use the \"unsecure\" variant, use simplesockets If you want to use the \"secure\" variant, use securesockets . For this one, you need pycryptodome Here you can learn more about the simplesockets Here you can learn more about the securesockets If you need an example, you can find one in the example folder. If you want a simple echo Client, it could look something like this: if __name__ == \"__main__\" : from simplesockets.simplesockets import TCPClient Client = TCPClient () Client . setup ( target_ip = \"localhost\" , target_port = 25567 ) #prepares the Client Client . connect () #connects the Client to the Server Client . autorecv () #enables autorecv: automaticle saves all incoming data in Client.recved_data, # return them with Client.return_recved_data() Client . send_data ( b 'Test' ) #sends the text to the Server while True : if Client . event . new_data : #checks if any data recved data = Client . return_recved_data () #returns the recved data as a list for element in data : print ( element ) #should return b'Test' A simple echo Server could look something like this: if __name__ == \"__main__\" : from simplesockets.simplesockets import TCPServer Server = TCPServer () Server . setup ( ip = '127.0.0.1' , port = 25567 ) #prepares the server Server . start () #starts the server while True : if Server . event . new_data : #checks if any data recved data = Server . return_recved_data () #returns the recved data as a list for element in data : client_socket , address , data = element #data is saved like this (client_socket,address,recved_data) Server . send_data ( data , client_socket ) If you encounter any bugs, report them on github Should you be interested in the changelog, you can find it here","title":"Welcome to simplesockets"},{"location":"Changelog/","text":"Roadmap: bugfixes more usability better documentation of the code cover the complete code with tests test for different python versions test for different operating systems Release 0.0.9: improved code documentation improved documentation removed ipv6 support first tests small additions small changes Release 0.0.8: added await_event(timeout=0) function to the Client and Server added documentation to the code added Address property to the Client added SetupError changed Project build bugfixes Release 0.0.7: autorecv() now can toggle the autorecv thread Server.killed() is now a property added a disconnect function to the Client added Address property to the Client added own exceptions fixed own encryption small changes Release 0.0.6: made all threads daemon made users_key public, added connected_users property bugfixes small changes removed the exit() functions added documentation to the code Release 0.0.5: added __str__() and __repr__() added own RSA and Vigener\u00e9 for semi secure encryption without dependencies. added new Client and Server class with own RSA encryption and Vigener\u00e9. on_receive on the Server takes now 3 arguments: client_socket, address, recved added decrypt_data() function to the Secure Servers Release 0.0.4: fixed imports added more typehints Release 0.0.3: added on_connect , on_disconnect and on_receive functions changes to the exit() function bugfixes added hash functions in the cipher module securesockets is now a package containing S_Client and S_Server new event variable containing events and exceptions added ipv6 versions to S_Client and S_Server (untested). Release 0.0.2: created ipv6 versions Release 0.0.1: created TCPServer created TCPClient created TCPServer_secure created TCPClient_secure","title":"Changelog"},{"location":"Changelog/#roadmap","text":"bugfixes more usability better documentation of the code cover the complete code with tests test for different python versions test for different operating systems","title":"Roadmap:"},{"location":"Changelog/#release-009","text":"improved code documentation improved documentation removed ipv6 support first tests small additions small changes","title":"Release 0.0.9:"},{"location":"Changelog/#release-008","text":"added await_event(timeout=0) function to the Client and Server added documentation to the code added Address property to the Client added SetupError changed Project build bugfixes","title":"Release 0.0.8:"},{"location":"Changelog/#release-007","text":"autorecv() now can toggle the autorecv thread Server.killed() is now a property added a disconnect function to the Client added Address property to the Client added own exceptions fixed own encryption small changes","title":"Release 0.0.7:"},{"location":"Changelog/#release-006","text":"made all threads daemon made users_key public, added connected_users property bugfixes small changes removed the exit() functions added documentation to the code","title":"Release 0.0.6:"},{"location":"Changelog/#release-005","text":"added __str__() and __repr__() added own RSA and Vigener\u00e9 for semi secure encryption without dependencies. added new Client and Server class with own RSA encryption and Vigener\u00e9. on_receive on the Server takes now 3 arguments: client_socket, address, recved added decrypt_data() function to the Secure Servers","title":"Release 0.0.5:"},{"location":"Changelog/#release-004","text":"fixed imports added more typehints","title":"Release 0.0.4:"},{"location":"Changelog/#release-003","text":"added on_connect , on_disconnect and on_receive functions changes to the exit() function bugfixes added hash functions in the cipher module securesockets is now a package containing S_Client and S_Server new event variable containing events and exceptions added ipv6 versions to S_Client and S_Server (untested).","title":"Release 0.0.3:"},{"location":"Changelog/#release-002","text":"created ipv6 versions","title":"Release 0.0.2:"},{"location":"Changelog/#release-001","text":"created TCPServer created TCPClient created TCPServer_secure created TCPClient_secure","title":"Release 0.0.1:"},{"location":"PyCryptodome_Socket-reference/","text":"PyCryptodome_Socket module SecureClient connected_users : list property readonly list of all users in the self.users_keys dict __init__ ( self ) special Attributes: Name Type Description self.user str should contain the username of the Client self.pw str should contain the password of the Client self.seperators list bytes separating the received information's self.own_keys list contains the Keys, first the private, second the public self.server_key RsaKey should contain the Key of the Server self.users_keys dict should contain as a key the username, as the value the public Key connect ( self , user , pw ) function tries to connect Parameters: Name Type Description Default user str username required pw str password required Returns: Type Description bool returns True if connecting was successful get_key ( self , username ) function returns a key for a username Parameters: Name Type Description Default username str username used for finding the key required Returns: Type Description RsaKey returns a RSA Public key on_connect ( self ) this function is executed on connection recv_data ( self ) function collects all incoming data Returns: Type Description tuple tuple, first the target, second the type, third the data send_data ( self , target , type , data , username = None , key = None ) Sends data to the the username or given socket encrypted with a key Parameters: Name Type Description Default target bytes information used for target required type bytes information used for type required data bytes data to send required username str the username of the user to send, if not given, you must give a key None key RsaKey the RSA Public Key used for encryption, if not given, you must give an username None Returns: Type Description bool returns True if the sending was successful setup ( self , target_ip , target_port = 25567 , recv_buffer = 2048 , on_connect = None , on_disconnect = None , on_receive = None ) function sets up the Client Parameters: Name Type Description Default target_ip str IP the Client should connect to required target_port int PORT the Client should connect to 25567 recv_buffer int PORT the Client should connect to 2048 on_connect Callable function that will be executed on connection, it takes not arguments None on_disconnect Callable function that will be executed on disconnection, it takes no arguments None on_receive Callable function that will be executed on receive, it takes the received data as an argument None SecureServer __init__ ( self , max_connections = None ) special Parameters: Name Type Description Default max_connections int how many Clients can connect to the Server None Attributes: Name Type Description self.users contains the address as the key and the username as the value self.own_keys contains the private Key and the public Key self.client_keys contains the username as the key and the public Key as the value self.to_send_client_keys contains the username as the key and the public Key as bytes as the value self.seperators contains bytes separating the received information's self.filepath path to a json file containing usernames and their passwords self.indent indent used for json add_user ( self , username , pw , get = None ) adds a username and a password to the already given json file Parameters: Name Type Description Default username str the username required pw str the password required get Optional[str] calls the dict.get() function with the given parameter None check_user ( self , username , pw , get = None ) checks if the given username and password are in the json file and are valid Parameters: Name Type Description Default username str username to check required pw str password to check (not yet hashed) required get Optional[str] calls the dict.get() function with the given parameter None Returns: Type Description bool returns True if username and password are valid decrypt_data ( self , data ) function can be used for decrypting the received data with the Server RSA Private Key Parameters: Name Type Description Default data bytes data which should be decrypted required Returns: Type Description bytes returns decrypted data get_address_by_user ( self , user ) uses the username to get the address Parameters: Name Type Description Default user str username required Returns: Type Description tuple returns the address get_client_keys ( self ) Returns: Type Description bytes returns a copy of the dictonary containing clients and there importable keys get_public_key ( self , username ) gets the public key from the username Parameters: Name Type Description Default username str username required Returns: Type Description RsaKey returns a RSA Public Key load_users ( self , get = None ) this function loads the json file with the users and their passwords Parameters: Name Type Description Default get Optional[str] calls the dict.get() function with the given parameter None Returns: Type Description dict returns a dict on_connect ( self , address ) this function gets call when a new client connects to the Server on_disconnect ( self , address ) this function gets called when a client gets disconnected Parameters: Name Type Description Default address tuple the address, containing Ip and Port required recv_data ( self , client_socket ) function collects incoming data Parameters: Name Type Description Default client_socket socket client socket required Returns: Type Description tuple tuple: first the target, second the type, third the data save_users ( self , users , get = None ) saves the users and their password dict Parameters: Name Type Description Default users dict the users dictionary required get Optional[str] calls the dict.get() function with the given parameter None send_data ( self , target , type , data , username = None , key = None , client_socket = None , encr_data = True ) function sends encrypted data to a user or socket Parameters: Name Type Description Default target bytes information used for target required type bytes information used for type required data bytes data to send required username Optional[str] the username of the user to send, if not given, you must give a socket and a key None key Optional[Crypto.PublicKey.RSA.RsaKey] the RSA Public Key used for encryption, if not given, you must give an username None client_socket Optional[socket.socket] client socket, if not given, you must give an username None encr_data Optional[bool] if the data should be encrypted True Returns: Type Description bool returns True if the sending was successful setup ( self , filepath , ip = '127.0.0.1' , port = 25567 , listen = 5 , recv_buffer = 2048 , handle_client = None , on_connect = None , on_disconnect = None , on_receive = None ) prepares the Server Parameters: Name Type Description Default filepath str absolut Path of the json file containing usernames and their passwords required ip Optional[str] IP of the Server '127.0.0.1' port Optional[int] PORT the Server should listen on 25567 listen Optional[int] parameter for socket.listen() 5 recv_buffer int the receive buffer used for socket.recv() 2048 handle_client Callable the function for handling the Clients, should be left as None None on_connect Callable function that will be executed on connection, it takes the address(tuple) as an argument None on_disconnect Callable function that will be executed on disconnection, it takes the address(tuple) as an argument None on_receive Callable function that will be executed on receive, it takes the clientsocket, address, received data None","title":"Pycryptodome Variante"},{"location":"PyCryptodome_Socket-reference/#pycryptodome_socket-module","text":"","title":"PyCryptodome_Socket module"},{"location":"PyCryptodome_Socket-reference/#simplesockets.securesockets.PyCryptodome_Socket.SecureClient","text":"","title":"SecureClient"},{"location":"PyCryptodome_Socket-reference/#simplesockets.securesockets.PyCryptodome_Socket.SecureClient.connected_users","text":"list of all users in the self.users_keys dict","title":"connected_users"},{"location":"PyCryptodome_Socket-reference/#simplesockets.securesockets.PyCryptodome_Socket.SecureClient.__init__","text":"Attributes: Name Type Description self.user str should contain the username of the Client self.pw str should contain the password of the Client self.seperators list bytes separating the received information's self.own_keys list contains the Keys, first the private, second the public self.server_key RsaKey should contain the Key of the Server self.users_keys dict should contain as a key the username, as the value the public Key","title":"__init__()"},{"location":"PyCryptodome_Socket-reference/#simplesockets.securesockets.PyCryptodome_Socket.SecureClient.connect","text":"function tries to connect Parameters: Name Type Description Default user str username required pw str password required Returns: Type Description bool returns True if connecting was successful","title":"connect()"},{"location":"PyCryptodome_Socket-reference/#simplesockets.securesockets.PyCryptodome_Socket.SecureClient.get_key","text":"function returns a key for a username Parameters: Name Type Description Default username str username used for finding the key required Returns: Type Description RsaKey returns a RSA Public key","title":"get_key()"},{"location":"PyCryptodome_Socket-reference/#simplesockets.securesockets.PyCryptodome_Socket.SecureClient.on_connect","text":"this function is executed on connection","title":"on_connect()"},{"location":"PyCryptodome_Socket-reference/#simplesockets.securesockets.PyCryptodome_Socket.SecureClient.recv_data","text":"function collects all incoming data Returns: Type Description tuple tuple, first the target, second the type, third the data","title":"recv_data()"},{"location":"PyCryptodome_Socket-reference/#simplesockets.securesockets.PyCryptodome_Socket.SecureClient.send_data","text":"Sends data to the the username or given socket encrypted with a key Parameters: Name Type Description Default target bytes information used for target required type bytes information used for type required data bytes data to send required username str the username of the user to send, if not given, you must give a key None key RsaKey the RSA Public Key used for encryption, if not given, you must give an username None Returns: Type Description bool returns True if the sending was successful","title":"send_data()"},{"location":"PyCryptodome_Socket-reference/#simplesockets.securesockets.PyCryptodome_Socket.SecureClient.setup","text":"function sets up the Client Parameters: Name Type Description Default target_ip str IP the Client should connect to required target_port int PORT the Client should connect to 25567 recv_buffer int PORT the Client should connect to 2048 on_connect Callable function that will be executed on connection, it takes not arguments None on_disconnect Callable function that will be executed on disconnection, it takes no arguments None on_receive Callable function that will be executed on receive, it takes the received data as an argument None","title":"setup()"},{"location":"PyCryptodome_Socket-reference/#simplesockets.securesockets.PyCryptodome_Socket.SecureServer","text":"","title":"SecureServer"},{"location":"PyCryptodome_Socket-reference/#simplesockets.securesockets.PyCryptodome_Socket.SecureServer.__init__","text":"Parameters: Name Type Description Default max_connections int how many Clients can connect to the Server None Attributes: Name Type Description self.users contains the address as the key and the username as the value self.own_keys contains the private Key and the public Key self.client_keys contains the username as the key and the public Key as the value self.to_send_client_keys contains the username as the key and the public Key as bytes as the value self.seperators contains bytes separating the received information's self.filepath path to a json file containing usernames and their passwords self.indent indent used for json","title":"__init__()"},{"location":"PyCryptodome_Socket-reference/#simplesockets.securesockets.PyCryptodome_Socket.SecureServer.add_user","text":"adds a username and a password to the already given json file Parameters: Name Type Description Default username str the username required pw str the password required get Optional[str] calls the dict.get() function with the given parameter None","title":"add_user()"},{"location":"PyCryptodome_Socket-reference/#simplesockets.securesockets.PyCryptodome_Socket.SecureServer.check_user","text":"checks if the given username and password are in the json file and are valid Parameters: Name Type Description Default username str username to check required pw str password to check (not yet hashed) required get Optional[str] calls the dict.get() function with the given parameter None Returns: Type Description bool returns True if username and password are valid","title":"check_user()"},{"location":"PyCryptodome_Socket-reference/#simplesockets.securesockets.PyCryptodome_Socket.SecureServer.decrypt_data","text":"function can be used for decrypting the received data with the Server RSA Private Key Parameters: Name Type Description Default data bytes data which should be decrypted required Returns: Type Description bytes returns decrypted data","title":"decrypt_data()"},{"location":"PyCryptodome_Socket-reference/#simplesockets.securesockets.PyCryptodome_Socket.SecureServer.get_address_by_user","text":"uses the username to get the address Parameters: Name Type Description Default user str username required Returns: Type Description tuple returns the address","title":"get_address_by_user()"},{"location":"PyCryptodome_Socket-reference/#simplesockets.securesockets.PyCryptodome_Socket.SecureServer.get_client_keys","text":"Returns: Type Description bytes returns a copy of the dictonary containing clients and there importable keys","title":"get_client_keys()"},{"location":"PyCryptodome_Socket-reference/#simplesockets.securesockets.PyCryptodome_Socket.SecureServer.get_public_key","text":"gets the public key from the username Parameters: Name Type Description Default username str username required Returns: Type Description RsaKey returns a RSA Public Key","title":"get_public_key()"},{"location":"PyCryptodome_Socket-reference/#simplesockets.securesockets.PyCryptodome_Socket.SecureServer.load_users","text":"this function loads the json file with the users and their passwords Parameters: Name Type Description Default get Optional[str] calls the dict.get() function with the given parameter None Returns: Type Description dict returns a dict","title":"load_users()"},{"location":"PyCryptodome_Socket-reference/#simplesockets.securesockets.PyCryptodome_Socket.SecureServer.on_connect","text":"this function gets call when a new client connects to the Server","title":"on_connect()"},{"location":"PyCryptodome_Socket-reference/#simplesockets.securesockets.PyCryptodome_Socket.SecureServer.on_disconnect","text":"this function gets called when a client gets disconnected Parameters: Name Type Description Default address tuple the address, containing Ip and Port required","title":"on_disconnect()"},{"location":"PyCryptodome_Socket-reference/#simplesockets.securesockets.PyCryptodome_Socket.SecureServer.recv_data","text":"function collects incoming data Parameters: Name Type Description Default client_socket socket client socket required Returns: Type Description tuple tuple: first the target, second the type, third the data","title":"recv_data()"},{"location":"PyCryptodome_Socket-reference/#simplesockets.securesockets.PyCryptodome_Socket.SecureServer.save_users","text":"saves the users and their password dict Parameters: Name Type Description Default users dict the users dictionary required get Optional[str] calls the dict.get() function with the given parameter None","title":"save_users()"},{"location":"PyCryptodome_Socket-reference/#simplesockets.securesockets.PyCryptodome_Socket.SecureServer.send_data","text":"function sends encrypted data to a user or socket Parameters: Name Type Description Default target bytes information used for target required type bytes information used for type required data bytes data to send required username Optional[str] the username of the user to send, if not given, you must give a socket and a key None key Optional[Crypto.PublicKey.RSA.RsaKey] the RSA Public Key used for encryption, if not given, you must give an username None client_socket Optional[socket.socket] client socket, if not given, you must give an username None encr_data Optional[bool] if the data should be encrypted True Returns: Type Description bool returns True if the sending was successful","title":"send_data()"},{"location":"PyCryptodome_Socket-reference/#simplesockets.securesockets.PyCryptodome_Socket.SecureServer.setup","text":"prepares the Server Parameters: Name Type Description Default filepath str absolut Path of the json file containing usernames and their passwords required ip Optional[str] IP of the Server '127.0.0.1' port Optional[int] PORT the Server should listen on 25567 listen Optional[int] parameter for socket.listen() 5 recv_buffer int the receive buffer used for socket.recv() 2048 handle_client Callable the function for handling the Clients, should be left as None None on_connect Callable function that will be executed on connection, it takes the address(tuple) as an argument None on_disconnect Callable function that will be executed on disconnection, it takes the address(tuple) as an argument None on_receive Callable function that will be executed on receive, it takes the clientsocket, address, received data None","title":"setup()"},{"location":"Securesockets_selfwritten/","text":"Introduction There are two modules in securesockets: PyCryptodome_Socket and SelfmadeCipher_Socket. The PyCryptodome_Socket module requires pycryptodome . The SelfmadeCipher_Socket module does not require any dependencies. The use of the SelfmadeCipher_Socket module is not recommended. For real secure communication, use the Pycryptodome variant. Both variants already contain an on_connect function. The Server already contains an on_disconnect function.","title":"How to use"},{"location":"Securesockets_selfwritten/#introduction","text":"There are two modules in securesockets: PyCryptodome_Socket and SelfmadeCipher_Socket. The PyCryptodome_Socket module requires pycryptodome . The SelfmadeCipher_Socket module does not require any dependencies. The use of the SelfmadeCipher_Socket module is not recommended. For real secure communication, use the Pycryptodome variant. Both variants already contain an on_connect function. The Server already contains an on_disconnect function.","title":"Introduction"},{"location":"Selfmade_Crypto_Socket-reference/","text":"Selfmade_Crypto_Socket module SecureClient connected_users : list property readonly list of all users in the self.users_keys dict __init__ ( self ) special Attributes: Name Type Description self.user str should contain the username of the Client self.pw str should contain the password of the Client self.seperators list bytes separating the the received information's self.own_keys list contains the Keys, first the private, second the public self.server_key RSA_Public_Key should contain the Key of the Server self.users_keys dict should contain as a key the username, as the value the public Key connect ( self , user , pw ) function tries to connect Parameters: Name Type Description Default user str username required pw str password required Returns: Type Description bool returns True if connecting was successful get_key ( self , username ) function returns a key for a username Parameters: Name Type Description Default username str username used for finding the key required Returns: Type Description RSA_Public_Key returns a RSA Public key on_connect ( self ) this function is executed on connection recv_data ( self ) function collects all incoming data Returns: Type Description tuple tuple, first the target, second the type, third the data send_data ( self , target , type , data , username = None , key = None ) Sends data to the the username or given socket encrypted with a key Parameters: Name Type Description Default target bytes information used for target required type bytes information used for type required data bytes data to send required username Optional[str] the username of the user to send, if not given, you must give a key None key Optional[simplesockets._support_files.RSA.RSA_Public_Key] the RSA Public Key used for encryption, if not given, you must give an username None Returns: Type Description bool returns True if the sending was successful setup ( self , target_ip , target_port = 25567 , recv_buffer = 2048 , on_connect = None , on_disconnect = None , on_receive = None ) function sets up the Client Parameters: Name Type Description Default target_ip str IP the Client should connect to required target_port Optional[int] PORT the Client should connect to 25567 recv_buffer Optional[int] PORT the Client should connect to 2048 on_connect Optional[Callable] function that will be executed on connection, it takes not arguments None on_disconnect Optional[Callable] function that will be executed on disconnection, it takes no arguments None on_receive Optional[Callable] function that will be executed on receive, it takes the received data as an argument None SecureServer __init__ ( self , max_connections = None ) special Parameters: Name Type Description Default max_connections Optional[int] how many Clients can connect to the Server None Attributes: Name Type Description self.users contains the address as the key and the username as the value self.own_keys contains the private Key and the public Key self.client_keys contains the username as the key and the public Key as the value self.to_send_client_keys contains the username as the key and the public Key as bytes as the value self.seperators contains bytes separating the received information's self.filepath path to a json file containing usernames and their passwords self.indent indent used for json add_user ( self , username , pw , get = None ) adds a username and a password to the already given json file Parameters: Name Type Description Default username str the username required pw str the password required get Optional[str] calls the dict.get() function with the given parameter None check_user ( self , username , pw , get = None ) checks if the given username and password are in the json file and are valid Parameters: Name Type Description Default username str username to check required pw str password to check (not yet hashed) required get Optional[str] calls the dict.get() function with the given parameter None Returns: Type Description bool returns True if username and password are valid decrypt_data ( self , data ) function can be used for decrypting the received data with the Server RSA Private Key Parameters: Name Type Description Default data bytes data which should be decrypted required Returns: Type Description bytes returns decrypted data get_address_by_user ( self , user ) uses the username to get the address Parameters: Name Type Description Default user str username required Returns: Type Description tuple returns the address get_client_keys ( self ) Returns: Type Description bytes returns a copy of the dictonary containing clients and there importable keys get_public_key ( self , username ) gets the public key from the username Parameters: Name Type Description Default username str username required Returns: Type Description RSA_Public_Key returns a RSA Public Key load_users ( self , get = None ) this function loads the json file with the users and their passwords Parameters: Name Type Description Default get Optional[str] calls the dict.get() function with the given parameter None Returns: Type Description dict returns a dict on_connect ( self , address ) this function gets call when a new client connects to the Server on_disconnect ( self , address ) this function gets called when a client gets disconnected Parameters: Name Type Description Default address tuple the address, containing Ip and Port required recv_data ( self , client_socket ) function collects incoming data Parameters: Name Type Description Default client_socket socket client socket required Returns: Type Description tuple tuple: first the target, second the type, third the data save_users ( self , users , get = None ) saves the users and their password dict Parameters: Name Type Description Default users dict the users dictionary required get Optional[str] calls the dict.get() function with the given parameter None send_data ( self , target , type , data , username = None , key = None , client_socket = None , encr_data = True ) function sends encrypted data to a user or socket Parameters: Name Type Description Default target bytes information used for target required type bytes information used for type required data bytes data to send required username Optional[str] the username of the user to send, if not given, you must give a socket and a key None key Optional[simplesockets._support_files.RSA.RSA_Public_Key] the RSA Public Key used for encryption, if not given, you must give an username None client_socket Optional[socket.socket] client socket, if not given, you must give an username None encr_data Optional[bool] if the data should be encrypted True Returns: Type Description bool returns True if the sending was successful setup ( self , filepath , ip = '127.0.0.1' , port = 25567 , listen = 5 , recv_buffer = 2048 , handle_client = None , on_connect = None , on_disconnect = None , on_receive = None ) prepares the Server Parameters: Name Type Description Default filepath str absolut Path of the json file containing usernames and their passwords required ip Optional[str] IP of the Server '127.0.0.1' port Optional[int] PORT the Server should listen on 25567 listen Optional[int] parameter for socket.listen() 5 recv_buffer Optional[int] the receive buffer used for socket.recv() 2048 handle_client Optional[Callable] the function for handling the Clients, should be left as None None on_connect Optional[Callable] function that will be executed on connection, it takes the address(tuple) as an argument None on_disconnect Optional[Callable] function that will be executed on disconnection, it takes the address(tuple) as an argument None on_receive Optional[Callable] function that will be executed on receive, it takes the clientsocket, address, received data None","title":"Selfmade Variante"},{"location":"Selfmade_Crypto_Socket-reference/#selfmade_crypto_socket-module","text":"","title":"Selfmade_Crypto_Socket module"},{"location":"Selfmade_Crypto_Socket-reference/#simplesockets.securesockets.SelfmadeCipher_Socket.SecureClient","text":"","title":"SecureClient"},{"location":"Selfmade_Crypto_Socket-reference/#simplesockets.securesockets.SelfmadeCipher_Socket.SecureClient.connected_users","text":"list of all users in the self.users_keys dict","title":"connected_users"},{"location":"Selfmade_Crypto_Socket-reference/#simplesockets.securesockets.SelfmadeCipher_Socket.SecureClient.__init__","text":"Attributes: Name Type Description self.user str should contain the username of the Client self.pw str should contain the password of the Client self.seperators list bytes separating the the received information's self.own_keys list contains the Keys, first the private, second the public self.server_key RSA_Public_Key should contain the Key of the Server self.users_keys dict should contain as a key the username, as the value the public Key","title":"__init__()"},{"location":"Selfmade_Crypto_Socket-reference/#simplesockets.securesockets.SelfmadeCipher_Socket.SecureClient.connect","text":"function tries to connect Parameters: Name Type Description Default user str username required pw str password required Returns: Type Description bool returns True if connecting was successful","title":"connect()"},{"location":"Selfmade_Crypto_Socket-reference/#simplesockets.securesockets.SelfmadeCipher_Socket.SecureClient.get_key","text":"function returns a key for a username Parameters: Name Type Description Default username str username used for finding the key required Returns: Type Description RSA_Public_Key returns a RSA Public key","title":"get_key()"},{"location":"Selfmade_Crypto_Socket-reference/#simplesockets.securesockets.SelfmadeCipher_Socket.SecureClient.on_connect","text":"this function is executed on connection","title":"on_connect()"},{"location":"Selfmade_Crypto_Socket-reference/#simplesockets.securesockets.SelfmadeCipher_Socket.SecureClient.recv_data","text":"function collects all incoming data Returns: Type Description tuple tuple, first the target, second the type, third the data","title":"recv_data()"},{"location":"Selfmade_Crypto_Socket-reference/#simplesockets.securesockets.SelfmadeCipher_Socket.SecureClient.send_data","text":"Sends data to the the username or given socket encrypted with a key Parameters: Name Type Description Default target bytes information used for target required type bytes information used for type required data bytes data to send required username Optional[str] the username of the user to send, if not given, you must give a key None key Optional[simplesockets._support_files.RSA.RSA_Public_Key] the RSA Public Key used for encryption, if not given, you must give an username None Returns: Type Description bool returns True if the sending was successful","title":"send_data()"},{"location":"Selfmade_Crypto_Socket-reference/#simplesockets.securesockets.SelfmadeCipher_Socket.SecureClient.setup","text":"function sets up the Client Parameters: Name Type Description Default target_ip str IP the Client should connect to required target_port Optional[int] PORT the Client should connect to 25567 recv_buffer Optional[int] PORT the Client should connect to 2048 on_connect Optional[Callable] function that will be executed on connection, it takes not arguments None on_disconnect Optional[Callable] function that will be executed on disconnection, it takes no arguments None on_receive Optional[Callable] function that will be executed on receive, it takes the received data as an argument None","title":"setup()"},{"location":"Selfmade_Crypto_Socket-reference/#simplesockets.securesockets.SelfmadeCipher_Socket.SecureServer","text":"","title":"SecureServer"},{"location":"Selfmade_Crypto_Socket-reference/#simplesockets.securesockets.SelfmadeCipher_Socket.SecureServer.__init__","text":"Parameters: Name Type Description Default max_connections Optional[int] how many Clients can connect to the Server None Attributes: Name Type Description self.users contains the address as the key and the username as the value self.own_keys contains the private Key and the public Key self.client_keys contains the username as the key and the public Key as the value self.to_send_client_keys contains the username as the key and the public Key as bytes as the value self.seperators contains bytes separating the received information's self.filepath path to a json file containing usernames and their passwords self.indent indent used for json","title":"__init__()"},{"location":"Selfmade_Crypto_Socket-reference/#simplesockets.securesockets.SelfmadeCipher_Socket.SecureServer.add_user","text":"adds a username and a password to the already given json file Parameters: Name Type Description Default username str the username required pw str the password required get Optional[str] calls the dict.get() function with the given parameter None","title":"add_user()"},{"location":"Selfmade_Crypto_Socket-reference/#simplesockets.securesockets.SelfmadeCipher_Socket.SecureServer.check_user","text":"checks if the given username and password are in the json file and are valid Parameters: Name Type Description Default username str username to check required pw str password to check (not yet hashed) required get Optional[str] calls the dict.get() function with the given parameter None Returns: Type Description bool returns True if username and password are valid","title":"check_user()"},{"location":"Selfmade_Crypto_Socket-reference/#simplesockets.securesockets.SelfmadeCipher_Socket.SecureServer.decrypt_data","text":"function can be used for decrypting the received data with the Server RSA Private Key Parameters: Name Type Description Default data bytes data which should be decrypted required Returns: Type Description bytes returns decrypted data","title":"decrypt_data()"},{"location":"Selfmade_Crypto_Socket-reference/#simplesockets.securesockets.SelfmadeCipher_Socket.SecureServer.get_address_by_user","text":"uses the username to get the address Parameters: Name Type Description Default user str username required Returns: Type Description tuple returns the address","title":"get_address_by_user()"},{"location":"Selfmade_Crypto_Socket-reference/#simplesockets.securesockets.SelfmadeCipher_Socket.SecureServer.get_client_keys","text":"Returns: Type Description bytes returns a copy of the dictonary containing clients and there importable keys","title":"get_client_keys()"},{"location":"Selfmade_Crypto_Socket-reference/#simplesockets.securesockets.SelfmadeCipher_Socket.SecureServer.get_public_key","text":"gets the public key from the username Parameters: Name Type Description Default username str username required Returns: Type Description RSA_Public_Key returns a RSA Public Key","title":"get_public_key()"},{"location":"Selfmade_Crypto_Socket-reference/#simplesockets.securesockets.SelfmadeCipher_Socket.SecureServer.load_users","text":"this function loads the json file with the users and their passwords Parameters: Name Type Description Default get Optional[str] calls the dict.get() function with the given parameter None Returns: Type Description dict returns a dict","title":"load_users()"},{"location":"Selfmade_Crypto_Socket-reference/#simplesockets.securesockets.SelfmadeCipher_Socket.SecureServer.on_connect","text":"this function gets call when a new client connects to the Server","title":"on_connect()"},{"location":"Selfmade_Crypto_Socket-reference/#simplesockets.securesockets.SelfmadeCipher_Socket.SecureServer.on_disconnect","text":"this function gets called when a client gets disconnected Parameters: Name Type Description Default address tuple the address, containing Ip and Port required","title":"on_disconnect()"},{"location":"Selfmade_Crypto_Socket-reference/#simplesockets.securesockets.SelfmadeCipher_Socket.SecureServer.recv_data","text":"function collects incoming data Parameters: Name Type Description Default client_socket socket client socket required Returns: Type Description tuple tuple: first the target, second the type, third the data","title":"recv_data()"},{"location":"Selfmade_Crypto_Socket-reference/#simplesockets.securesockets.SelfmadeCipher_Socket.SecureServer.save_users","text":"saves the users and their password dict Parameters: Name Type Description Default users dict the users dictionary required get Optional[str] calls the dict.get() function with the given parameter None","title":"save_users()"},{"location":"Selfmade_Crypto_Socket-reference/#simplesockets.securesockets.SelfmadeCipher_Socket.SecureServer.send_data","text":"function sends encrypted data to a user or socket Parameters: Name Type Description Default target bytes information used for target required type bytes information used for type required data bytes data to send required username Optional[str] the username of the user to send, if not given, you must give a socket and a key None key Optional[simplesockets._support_files.RSA.RSA_Public_Key] the RSA Public Key used for encryption, if not given, you must give an username None client_socket Optional[socket.socket] client socket, if not given, you must give an username None encr_data Optional[bool] if the data should be encrypted True Returns: Type Description bool returns True if the sending was successful","title":"send_data()"},{"location":"Selfmade_Crypto_Socket-reference/#simplesockets.securesockets.SelfmadeCipher_Socket.SecureServer.setup","text":"prepares the Server Parameters: Name Type Description Default filepath str absolut Path of the json file containing usernames and their passwords required ip Optional[str] IP of the Server '127.0.0.1' port Optional[int] PORT the Server should listen on 25567 listen Optional[int] parameter for socket.listen() 5 recv_buffer Optional[int] the receive buffer used for socket.recv() 2048 handle_client Optional[Callable] the function for handling the Clients, should be left as None None on_connect Optional[Callable] function that will be executed on connection, it takes the address(tuple) as an argument None on_disconnect Optional[Callable] function that will be executed on disconnection, it takes the address(tuple) as an argument None on_receive Optional[Callable] function that will be executed on receive, it takes the clientsocket, address, received data None","title":"setup()"},{"location":"simple_sockets-reference/","text":"simplesockets module TCPClient This class contains functions for connecting and keeping connections alive Attributes: Name Type Description self.EVENT_EXCEPTION str Returned by await_event() if an exception occurred self.EVENT_RECEIVED str Returned by await_event() if the client received data self.EVENT_TIMEOUT str Returned by await_event() if the function timed out self.EVENT_DISCONNECT str Returned by await_event() if client disconnected self.EVENT_CONNECTED str Returned by await_event() if client connected self.event.new_data bool Is True if the Client received new data self.event.disconnected bool Is True if the Client disconnected self.event.is_connected bool Is True if the Client is connected to the Server self.event.connected bool Is True if the Client connected self.event.exception.occurred bool Is True if an exception got caught self.event.exception.list list contains all caught exceptions self.recved_data list contains all received data Address : tuple property readonly Address of the Client, containing it's ip and port autorecv ( self ) function which activates the auto-receiving thread, automatically saving all incoming data await_event ( self , timeout = 0 , disable_on_functions = False ) waits till an event occurs Parameters: Name Type Description Default timeout Optional[int] time till timeout in milliseconds 0 disable_on_functions Optional[bool] If True, will set __connected and __disconnected flag to False False Returns: Type Description Union[Tuple[str, list], Tuple[str]] returns event and its value(s) connect ( self ) tries to connect to the Server Returns: Type Description bool returns a bool if the connecting was successful disconnect ( self ) tries to disconnect from the Server Returns: Type Description bool returns true if the client disconnected without an exception reconnect ( self ) tries to reconnect to the Server Returns: Type Description bool returns a bool if the connecting was successful recv_data ( self ) function collects incoming data. If you want to collect all incoming data automatically, use Client.autorecv() Returns: Type Description bytes returns received data as bytes return_exceptions ( self , delete = True , reset_exceptions = True ) this function returns all collected exceptions Parameters: Name Type Description Default delete Optional[bool] If the list which collected the exceptions should be cleared True reset_exceptions Optional[bool] If the exception occurred variable should be reset (set to False) True Returns: Type Description List[tuple] returns a list of all collected exceptions return_recved_data ( self ) returns received data Returns: Type Description List[bytes] returns a list of the received data send_data ( self , data ) tries to send data to the Server Parameters: Name Type Description Default data bytes ata that should be send required Returns: Type Description bool returns True if the sending was successful setup ( self , target_ip , target_port = 25567 , recv_buffer = 2048 , on_connect = None , on_disconnect = None , on_receive = None ) function sets up the Client Parameters: Name Type Description Default target_ip str IP the Client should connect to required target_port Optional[int] PORT the Client should connect to 25567 recv_buffer Optional[int] The receive buffer used for socket.recv() 2048 on_connect Optional[Callable] Function that will be executed on connection, it takes not arguments None on_disconnect Optional[Callable] Function that will be executed on disconnection, it takes no arguments None on_receive Optional[Callable] Function that will be executed on receive, it takes the received data as an argument None shutdown ( self ) sets the flag in the autorecv thread to False and closes the socket TCPServer This class contains functions for accepting connections and keeping connections alive Attributes: Name Type Description self.EVENT_EXCEPTION str Returned by await_event() if an exception occurred self.EVENT_RECEIVED str Returned by await_event() if the client received data self.EVENT_TIMEOUT str Returned by await_event() if the function timed out self.event.new_data bool Is True if the Client received new data self.event.exception.occurred bool Is True if an exception got caught self.event.exception.list list contains all caught exceptions self.recved_data list contains all received data self.socket socket.socket is the Server Socket self.clients dict contains the address as the key and the client thread and socket as a list as the values killed : bool property readonly Returns: returns if the accepting thread got killed or not __init__ ( self , max_connections = None ) special Initializes the Server Parameters: Name Type Description Default max_connections Optional[int] how many Clients can connect to the Server None await_event ( self , timeout = 0 ) waits till an event occurs Parameters: Name Type Description Default timeout Optional[int] time till timeout in milliseconds. Zero means no timeout. 0 Returns: Type Description Union[Tuple[str, list], Tuple[str]] Union[Tuple[str, list], Tuple[str, None]]: returns event and its value(s) disconnect ( self , address ) disconnects a socket from the Server Parameters: Name Type Description Default address tuple the address of the client which you want to disconnect required exit_accept ( self ) stops and kills the accepting thread recv_data ( self , client_socket ) function collects incoming data Returns: Type Description bytes returns received data as bytes restart ( self ) function tries to restart the accepting thread return_exceptions ( self , delete = True , reset_exception = True ) Returns the collected exceptions Parameters: Name Type Description Default delete Optional[bool] If the list which collected the exceptions should be cleared True reset_exception Optional[bool] If the exception occurred variable should be reset (set to False) True Returns: Type Description list returns a list of all collected exceptions return_recved_data ( self ) returns received data Returns: Type Description List[bytes] returns a list of the received data send_data ( self , data , client_socket ) function for sending data to a specific clientsocket Parameters: Name Type Description Default data bytes data which should be send required client_socket socket the clientsocket from to which the data should be send to required Returns: Type Description bool returns True if the operation was successful setup ( self , ip = '127.0.0.1' , port = 25567 , listen = 5 , recv_buffer = 2048 , handle_client = None , on_connect = None , on_disconnect = None , on_receive = None ) function prepares the Server Parameters: Name Type Description Default ip Optional[str] IP of the Server '127.0.0.1' port Optional[int] PORT the Server should listen on 25567 listen Optional[int] parameter for socket.listen() 5 recv_buffer Optional[int] the receive buffer used for socket.recv() 2048 handle_client Optional[Callable] the function for handling the Clients, should be left as None None on_connect Optional[Callable] function that will be executed on connection, it takes the address(tuple) as an argument None on_disconnect Optional[Callable] function that will be executed on disconnection, it takes the address(tuple) as an argument None on_receive Optional[Callable] function that will be executed on receive, it takes the clientsocket, address, received data as an argument None start ( self ) starts the accepting thread Exceptions: Type Description SetupError If Client.setup() wasn't called before stop ( self ) stops the accepting thread","title":"Simplesockets"},{"location":"simple_sockets-reference/#simplesockets-module","text":"","title":"simplesockets module"},{"location":"simple_sockets-reference/#simplesockets.simple_sockets.TCPClient","text":"This class contains functions for connecting and keeping connections alive Attributes: Name Type Description self.EVENT_EXCEPTION str Returned by await_event() if an exception occurred self.EVENT_RECEIVED str Returned by await_event() if the client received data self.EVENT_TIMEOUT str Returned by await_event() if the function timed out self.EVENT_DISCONNECT str Returned by await_event() if client disconnected self.EVENT_CONNECTED str Returned by await_event() if client connected self.event.new_data bool Is True if the Client received new data self.event.disconnected bool Is True if the Client disconnected self.event.is_connected bool Is True if the Client is connected to the Server self.event.connected bool Is True if the Client connected self.event.exception.occurred bool Is True if an exception got caught self.event.exception.list list contains all caught exceptions self.recved_data list contains all received data","title":"TCPClient"},{"location":"simple_sockets-reference/#simplesockets.simple_sockets.TCPClient.Address","text":"Address of the Client, containing it's ip and port","title":"Address"},{"location":"simple_sockets-reference/#simplesockets.simple_sockets.TCPClient.autorecv","text":"function which activates the auto-receiving thread, automatically saving all incoming data","title":"autorecv()"},{"location":"simple_sockets-reference/#simplesockets.simple_sockets.TCPClient.await_event","text":"waits till an event occurs Parameters: Name Type Description Default timeout Optional[int] time till timeout in milliseconds 0 disable_on_functions Optional[bool] If True, will set __connected and __disconnected flag to False False Returns: Type Description Union[Tuple[str, list], Tuple[str]] returns event and its value(s)","title":"await_event()"},{"location":"simple_sockets-reference/#simplesockets.simple_sockets.TCPClient.connect","text":"tries to connect to the Server Returns: Type Description bool returns a bool if the connecting was successful","title":"connect()"},{"location":"simple_sockets-reference/#simplesockets.simple_sockets.TCPClient.disconnect","text":"tries to disconnect from the Server Returns: Type Description bool returns true if the client disconnected without an exception","title":"disconnect()"},{"location":"simple_sockets-reference/#simplesockets.simple_sockets.TCPClient.reconnect","text":"tries to reconnect to the Server Returns: Type Description bool returns a bool if the connecting was successful","title":"reconnect()"},{"location":"simple_sockets-reference/#simplesockets.simple_sockets.TCPClient.recv_data","text":"function collects incoming data. If you want to collect all incoming data automatically, use Client.autorecv() Returns: Type Description bytes returns received data as bytes","title":"recv_data()"},{"location":"simple_sockets-reference/#simplesockets.simple_sockets.TCPClient.return_exceptions","text":"this function returns all collected exceptions Parameters: Name Type Description Default delete Optional[bool] If the list which collected the exceptions should be cleared True reset_exceptions Optional[bool] If the exception occurred variable should be reset (set to False) True Returns: Type Description List[tuple] returns a list of all collected exceptions","title":"return_exceptions()"},{"location":"simple_sockets-reference/#simplesockets.simple_sockets.TCPClient.return_recved_data","text":"returns received data Returns: Type Description List[bytes] returns a list of the received data","title":"return_recved_data()"},{"location":"simple_sockets-reference/#simplesockets.simple_sockets.TCPClient.send_data","text":"tries to send data to the Server Parameters: Name Type Description Default data bytes ata that should be send required Returns: Type Description bool returns True if the sending was successful","title":"send_data()"},{"location":"simple_sockets-reference/#simplesockets.simple_sockets.TCPClient.setup","text":"function sets up the Client Parameters: Name Type Description Default target_ip str IP the Client should connect to required target_port Optional[int] PORT the Client should connect to 25567 recv_buffer Optional[int] The receive buffer used for socket.recv() 2048 on_connect Optional[Callable] Function that will be executed on connection, it takes not arguments None on_disconnect Optional[Callable] Function that will be executed on disconnection, it takes no arguments None on_receive Optional[Callable] Function that will be executed on receive, it takes the received data as an argument None","title":"setup()"},{"location":"simple_sockets-reference/#simplesockets.simple_sockets.TCPClient.shutdown","text":"sets the flag in the autorecv thread to False and closes the socket","title":"shutdown()"},{"location":"simple_sockets-reference/#simplesockets.simple_sockets.TCPServer","text":"This class contains functions for accepting connections and keeping connections alive Attributes: Name Type Description self.EVENT_EXCEPTION str Returned by await_event() if an exception occurred self.EVENT_RECEIVED str Returned by await_event() if the client received data self.EVENT_TIMEOUT str Returned by await_event() if the function timed out self.event.new_data bool Is True if the Client received new data self.event.exception.occurred bool Is True if an exception got caught self.event.exception.list list contains all caught exceptions self.recved_data list contains all received data self.socket socket.socket is the Server Socket self.clients dict contains the address as the key and the client thread and socket as a list as the values","title":"TCPServer"},{"location":"simple_sockets-reference/#simplesockets.simple_sockets.TCPServer.killed","text":"Returns: returns if the accepting thread got killed or not","title":"killed"},{"location":"simple_sockets-reference/#simplesockets.simple_sockets.TCPServer.__init__","text":"Initializes the Server Parameters: Name Type Description Default max_connections Optional[int] how many Clients can connect to the Server None","title":"__init__()"},{"location":"simple_sockets-reference/#simplesockets.simple_sockets.TCPServer.await_event","text":"waits till an event occurs Parameters: Name Type Description Default timeout Optional[int] time till timeout in milliseconds. Zero means no timeout. 0 Returns: Type Description Union[Tuple[str, list], Tuple[str]] Union[Tuple[str, list], Tuple[str, None]]: returns event and its value(s)","title":"await_event()"},{"location":"simple_sockets-reference/#simplesockets.simple_sockets.TCPServer.disconnect","text":"disconnects a socket from the Server Parameters: Name Type Description Default address tuple the address of the client which you want to disconnect required","title":"disconnect()"},{"location":"simple_sockets-reference/#simplesockets.simple_sockets.TCPServer.exit_accept","text":"stops and kills the accepting thread","title":"exit_accept()"},{"location":"simple_sockets-reference/#simplesockets.simple_sockets.TCPServer.recv_data","text":"function collects incoming data Returns: Type Description bytes returns received data as bytes","title":"recv_data()"},{"location":"simple_sockets-reference/#simplesockets.simple_sockets.TCPServer.restart","text":"function tries to restart the accepting thread","title":"restart()"},{"location":"simple_sockets-reference/#simplesockets.simple_sockets.TCPServer.return_exceptions","text":"Returns the collected exceptions Parameters: Name Type Description Default delete Optional[bool] If the list which collected the exceptions should be cleared True reset_exception Optional[bool] If the exception occurred variable should be reset (set to False) True Returns: Type Description list returns a list of all collected exceptions","title":"return_exceptions()"},{"location":"simple_sockets-reference/#simplesockets.simple_sockets.TCPServer.return_recved_data","text":"returns received data Returns: Type Description List[bytes] returns a list of the received data","title":"return_recved_data()"},{"location":"simple_sockets-reference/#simplesockets.simple_sockets.TCPServer.send_data","text":"function for sending data to a specific clientsocket Parameters: Name Type Description Default data bytes data which should be send required client_socket socket the clientsocket from to which the data should be send to required Returns: Type Description bool returns True if the operation was successful","title":"send_data()"},{"location":"simple_sockets-reference/#simplesockets.simple_sockets.TCPServer.setup","text":"function prepares the Server Parameters: Name Type Description Default ip Optional[str] IP of the Server '127.0.0.1' port Optional[int] PORT the Server should listen on 25567 listen Optional[int] parameter for socket.listen() 5 recv_buffer Optional[int] the receive buffer used for socket.recv() 2048 handle_client Optional[Callable] the function for handling the Clients, should be left as None None on_connect Optional[Callable] function that will be executed on connection, it takes the address(tuple) as an argument None on_disconnect Optional[Callable] function that will be executed on disconnection, it takes the address(tuple) as an argument None on_receive Optional[Callable] function that will be executed on receive, it takes the clientsocket, address, received data as an argument None","title":"setup()"},{"location":"simple_sockets-reference/#simplesockets.simple_sockets.TCPServer.start","text":"starts the accepting thread Exceptions: Type Description SetupError If Client.setup() wasn't called before","title":"start()"},{"location":"simple_sockets-reference/#simplesockets.simple_sockets.TCPServer.stop","text":"stops the accepting thread","title":"stop()"},{"location":"simple_sockets_selfwritten/","text":"Introduction This module contains two classes: TCPServer and TCPClient. Note: This Page is still under construction and may be outdated. For the newest code documentation look here . Server Let's get started with the TCPServer: Setting up and starting the Server is really easy: from simplesockets.simplesockets import TCPServer Server = TCPServer () # you could specify the max amount of conections Server . setup ( ip = \"127.0.0.1\" , port = 9999 ) # more options: listen=5, recv_buffer=2048, handle_client=None Server . start () When initializing the Server object, you can specify the amount of max connections: Server = TCPServer(5) . Then you need to call setup() . You can give the following arguments: - ip: The ip the Server binds to, standard: socket.gethostname() - port: The port the Server binds to, standard: 25567 - listen: Is the value used in socket.listen() , standard: 5 - recv_buffer: Is the amount of bytes the socket receives at maximum, standard: 2048 - handle_client: The function used for handling a Client which has been accepted, standard: None , I recommend to not change anything here - on_connect: This variable should contain a function. It will be executed, when the Server got a new connection. It takes the address as an argument. standard: None - on_disconnect: This variable should contain a function. It will be executed, when a Client disconnects from the Server. It takes the address as an argument. standard: None - on_receive: This variable should contain a function. It will be executed when the Client received new data. It takes the client socket, address and received data as an argument. Now the Server must do something. We will build an echo Server, which will disconnect the Client after sending the received text. I recommend using a while loop to keep the server going. while True : if Server . event . new_data : recved_data = Server . return_recved_data () The Server.event.new_data variable is True if the Server received new data. The Server.return_recved_data() function returns the received data and turns the Server.event.new_data variable False. The returned variable is a list of all received data. Now you need to iterate over them. for data_element in recved_data : clientsocket , address , data = data_element After iterating you will have a variable, here called data_element . It is a tuple containing a socket object from the Client, the address of the sender and the sent data. Now we can use the socket object for sending the data back, then we can close the connection. Therefore, we call Server.send_data() . It takes two arguments: - data: The data that you want to send. It should be type bytes - client_socket: The socket of the client Server . send_data ( data , clientsocket ) Server . disconnect ( clientsocket ) Now we are finished. Here the complete code: from simplesockets.simplesockets import TCPServer Server = TCPServer () Server . setup ( ip = '127.0.0.1' , port = 9999 ) Server . start () while True : if Server . new_data_recved : #checks if any data recved recved_data = Server . return_recved_data () #returns the recved data as a list for data_element in recved_data : client_socket , address , data = data_element Server . send_data ( data , client_socket ) Server . disconnect ( client_socket ) Now we are going to take a look at all the functions we did not cover yet. Server Functions The setup(self, ip: str = socket.gethostname(), port: int = 25567, listen: int = 5, recv_buffer: int = 2048, handle_client=None, on_connect=None, on_disconnect=None, on_receive=None): function prepares the Server. It got explained already. The Server.exit_accept() function stops and kills the accepting thread. The Server.stop() function pauses the accepting thread. You can start it again with Server.start() . The same function is used when the amount of connections reaches the defined limit. The Server.recv_data(client_socket) function is automatically called. You don't have to use it for receiving data. The Server.killed() property returns True if the accepting thread got killed The Server.restart() function will restart the accepting thread. If you want to accept Clients, make sure the Server.event.accepting_thread.run variable is True. The Server.return_exceptions(delete=True, reset_exception=True) returns all exceptions the class could catch. Use the Server.event.exception.occurred variable to check if an exception got caught. It can take two arguments. If delete=True , Server.event.exception.list gets reset. If reset_exception=True , Server.exception will be set False. The Server.disconnect(address) function tries to disconnect a connection to the address Now, let's cover some variables Server Variables The Server.recved_data variable contains all the received data. I recommend using the Server.return_recved_data() for using the received data. The Server.event.accepting_thread.run variable is True if the accepting thread is running. The Server.event.exception.occurred variable is True if any exceptions got caught. You can find the exceptions in the Server,event.exception.list variable. The Server.event.new_data variable is True if the Server received new data. The Server.socket variable contains the Server socket. The Server.clients variable is a dictionary. The key is the address, the value is a list of the Client Thread as it's first value, and the Client socket as it second value. The Server.max_connections variable defines how many connections the Server accepts before refusing new connections. It can be defined in the initialization of the Server object: Server = TCPServer(5) . The Server.on_connect , Server.on_disconnect and Server.on_receive variables should contain functions. The Server.on_connect and Server.on_disconnect take the address as an argument. The Server.on_receive takes the received data as an argument. Client Let's get started with the Client. First you initialise the Client. Then you need to call setup() . You can give the following arguments: - target_ip: The ip the Client connects to - target_port: The port the Client connects to, standard: 25567 - listen: Is the value used in socket.listen() , standard: 5 - recv_buffer: Is the amount of bytes the socket receives at maximum, standard: 2048 - on_connect: This variable should contain a function. It will be executed right after the Client connected to the Server. It takes no arguments. - on_disconnect: This variable should contain a function. It will be executed when the Client disconnects from the Server - on_receive: This variable should contain a function. It will be executed when the Client received new data. It takes the received data as an argument. from simplesockets.simplesockets import TCPClient Client = TCPClient () Client . setup ( target_ip = 'localhost' , target_port = 9999 ) # more options: listen=5, recv_buffer=2048, handle_client=None It's almost the same as with the Server. Next we need to connect to the Server. Client . connect () Client . autorecv () The Client.autorecv() starts a Thread which collects all incoming data. Client . send_data ( b 'Test) while True : if Client . event . new_data : Then the Clients sends his message. Next, we wait for incoming data in a while loop. Should we receive data trough the Client.autorecv() , Client.new_data_recved will be true. recved_data = Client . return_recved_data () for data_element in recved_data : print ( data_element ) Here is the complete code: from simplesockets.simplesockets import TCPClient Client = TCPClient () Client . setup ( target_ip = 'localhost' , target_port = 9999 ) # more options: listen=5, recv_buffer=2048, handle_client=None Client . start () Client . connect () Client . autorecv () Client . send_data ( b 'Test' ) while True : if Client . event . new_data : recved_data = Client . return_recved_data () for data_element in recved_data : print ( data_element ) Now we should take al look at all functions we didn't cover yet. Client Functions The Client.setup(target_ip: str, target_port: int = 25567, recv_buffer: int = 2048, on_connect: Callable = None, on_disconnect: Callable = None, on_receive: Callable = None): function prepares the Client. This function got explained previously. The Client.connect() function tries to connect to the Server. The Client.send_data(data: bytes) function tries to send the given data to the Server. The Client.reconnect() function try's to reconnect to the Server. The Client.shutdown() function ends the autrecv Thread end closes the Connection. The Client.return_exceptions() returns all exceptions The Client.return_recved_data() function returns the received data and sets Client.event.new_data to False. The Client.autorecv() function toggles the autorecv_thread . It starts stopped. The Client.disconnect() function tries to disconnect from the Server. Client Variables The Client.recved_data variable contains all the received data. I recommend using the Client.return_recved_data() for using the received data. The Client.socket variable contains the Client socket. The Client.event.exception.occurred variable is true if any exceptions raised and got caught. The Client.event.exception.list variable contains all caught exceptions. The CLient.event.new_data variable is true if the Client received any new data. The Client.event.disconnected variable is True if the Client disconnected from the Serer. The Client.event.connected variable is True if the connecting proccess to the Server was succesful. The Client.event.is_connected variable is True if the Client is connected to the Server. The Client.Address property is a tuple of the target_ip and the target_port.","title":"How to use"},{"location":"simple_sockets_selfwritten/#introduction","text":"This module contains two classes: TCPServer and TCPClient. Note: This Page is still under construction and may be outdated. For the newest code documentation look here .","title":"Introduction"},{"location":"simple_sockets_selfwritten/#server","text":"Let's get started with the TCPServer: Setting up and starting the Server is really easy: from simplesockets.simplesockets import TCPServer Server = TCPServer () # you could specify the max amount of conections Server . setup ( ip = \"127.0.0.1\" , port = 9999 ) # more options: listen=5, recv_buffer=2048, handle_client=None Server . start () When initializing the Server object, you can specify the amount of max connections: Server = TCPServer(5) . Then you need to call setup() . You can give the following arguments: - ip: The ip the Server binds to, standard: socket.gethostname() - port: The port the Server binds to, standard: 25567 - listen: Is the value used in socket.listen() , standard: 5 - recv_buffer: Is the amount of bytes the socket receives at maximum, standard: 2048 - handle_client: The function used for handling a Client which has been accepted, standard: None , I recommend to not change anything here - on_connect: This variable should contain a function. It will be executed, when the Server got a new connection. It takes the address as an argument. standard: None - on_disconnect: This variable should contain a function. It will be executed, when a Client disconnects from the Server. It takes the address as an argument. standard: None - on_receive: This variable should contain a function. It will be executed when the Client received new data. It takes the client socket, address and received data as an argument. Now the Server must do something. We will build an echo Server, which will disconnect the Client after sending the received text. I recommend using a while loop to keep the server going. while True : if Server . event . new_data : recved_data = Server . return_recved_data () The Server.event.new_data variable is True if the Server received new data. The Server.return_recved_data() function returns the received data and turns the Server.event.new_data variable False. The returned variable is a list of all received data. Now you need to iterate over them. for data_element in recved_data : clientsocket , address , data = data_element After iterating you will have a variable, here called data_element . It is a tuple containing a socket object from the Client, the address of the sender and the sent data. Now we can use the socket object for sending the data back, then we can close the connection. Therefore, we call Server.send_data() . It takes two arguments: - data: The data that you want to send. It should be type bytes - client_socket: The socket of the client Server . send_data ( data , clientsocket ) Server . disconnect ( clientsocket ) Now we are finished. Here the complete code: from simplesockets.simplesockets import TCPServer Server = TCPServer () Server . setup ( ip = '127.0.0.1' , port = 9999 ) Server . start () while True : if Server . new_data_recved : #checks if any data recved recved_data = Server . return_recved_data () #returns the recved data as a list for data_element in recved_data : client_socket , address , data = data_element Server . send_data ( data , client_socket ) Server . disconnect ( client_socket ) Now we are going to take a look at all the functions we did not cover yet.","title":"Server"},{"location":"simple_sockets_selfwritten/#server-functions","text":"The setup(self, ip: str = socket.gethostname(), port: int = 25567, listen: int = 5, recv_buffer: int = 2048, handle_client=None, on_connect=None, on_disconnect=None, on_receive=None): function prepares the Server. It got explained already. The Server.exit_accept() function stops and kills the accepting thread. The Server.stop() function pauses the accepting thread. You can start it again with Server.start() . The same function is used when the amount of connections reaches the defined limit. The Server.recv_data(client_socket) function is automatically called. You don't have to use it for receiving data. The Server.killed() property returns True if the accepting thread got killed The Server.restart() function will restart the accepting thread. If you want to accept Clients, make sure the Server.event.accepting_thread.run variable is True. The Server.return_exceptions(delete=True, reset_exception=True) returns all exceptions the class could catch. Use the Server.event.exception.occurred variable to check if an exception got caught. It can take two arguments. If delete=True , Server.event.exception.list gets reset. If reset_exception=True , Server.exception will be set False. The Server.disconnect(address) function tries to disconnect a connection to the address Now, let's cover some variables","title":"Server Functions"},{"location":"simple_sockets_selfwritten/#server-variables","text":"The Server.recved_data variable contains all the received data. I recommend using the Server.return_recved_data() for using the received data. The Server.event.accepting_thread.run variable is True if the accepting thread is running. The Server.event.exception.occurred variable is True if any exceptions got caught. You can find the exceptions in the Server,event.exception.list variable. The Server.event.new_data variable is True if the Server received new data. The Server.socket variable contains the Server socket. The Server.clients variable is a dictionary. The key is the address, the value is a list of the Client Thread as it's first value, and the Client socket as it second value. The Server.max_connections variable defines how many connections the Server accepts before refusing new connections. It can be defined in the initialization of the Server object: Server = TCPServer(5) . The Server.on_connect , Server.on_disconnect and Server.on_receive variables should contain functions. The Server.on_connect and Server.on_disconnect take the address as an argument. The Server.on_receive takes the received data as an argument.","title":"Server Variables"},{"location":"simple_sockets_selfwritten/#client","text":"Let's get started with the Client. First you initialise the Client. Then you need to call setup() . You can give the following arguments: - target_ip: The ip the Client connects to - target_port: The port the Client connects to, standard: 25567 - listen: Is the value used in socket.listen() , standard: 5 - recv_buffer: Is the amount of bytes the socket receives at maximum, standard: 2048 - on_connect: This variable should contain a function. It will be executed right after the Client connected to the Server. It takes no arguments. - on_disconnect: This variable should contain a function. It will be executed when the Client disconnects from the Server - on_receive: This variable should contain a function. It will be executed when the Client received new data. It takes the received data as an argument. from simplesockets.simplesockets import TCPClient Client = TCPClient () Client . setup ( target_ip = 'localhost' , target_port = 9999 ) # more options: listen=5, recv_buffer=2048, handle_client=None It's almost the same as with the Server. Next we need to connect to the Server. Client . connect () Client . autorecv () The Client.autorecv() starts a Thread which collects all incoming data. Client . send_data ( b 'Test) while True : if Client . event . new_data : Then the Clients sends his message. Next, we wait for incoming data in a while loop. Should we receive data trough the Client.autorecv() , Client.new_data_recved will be true. recved_data = Client . return_recved_data () for data_element in recved_data : print ( data_element ) Here is the complete code: from simplesockets.simplesockets import TCPClient Client = TCPClient () Client . setup ( target_ip = 'localhost' , target_port = 9999 ) # more options: listen=5, recv_buffer=2048, handle_client=None Client . start () Client . connect () Client . autorecv () Client . send_data ( b 'Test' ) while True : if Client . event . new_data : recved_data = Client . return_recved_data () for data_element in recved_data : print ( data_element ) Now we should take al look at all functions we didn't cover yet.","title":"Client"},{"location":"simple_sockets_selfwritten/#client-functions","text":"The Client.setup(target_ip: str, target_port: int = 25567, recv_buffer: int = 2048, on_connect: Callable = None, on_disconnect: Callable = None, on_receive: Callable = None): function prepares the Client. This function got explained previously. The Client.connect() function tries to connect to the Server. The Client.send_data(data: bytes) function tries to send the given data to the Server. The Client.reconnect() function try's to reconnect to the Server. The Client.shutdown() function ends the autrecv Thread end closes the Connection. The Client.return_exceptions() returns all exceptions The Client.return_recved_data() function returns the received data and sets Client.event.new_data to False. The Client.autorecv() function toggles the autorecv_thread . It starts stopped. The Client.disconnect() function tries to disconnect from the Server.","title":"Client Functions"},{"location":"simple_sockets_selfwritten/#client-variables","text":"The Client.recved_data variable contains all the received data. I recommend using the Client.return_recved_data() for using the received data. The Client.socket variable contains the Client socket. The Client.event.exception.occurred variable is true if any exceptions raised and got caught. The Client.event.exception.list variable contains all caught exceptions. The CLient.event.new_data variable is true if the Client received any new data. The Client.event.disconnected variable is True if the Client disconnected from the Serer. The Client.event.connected variable is True if the connecting proccess to the Server was succesful. The Client.event.is_connected variable is True if the Client is connected to the Server. The Client.Address property is a tuple of the target_ip and the target_port.","title":"Client Variables"}]}